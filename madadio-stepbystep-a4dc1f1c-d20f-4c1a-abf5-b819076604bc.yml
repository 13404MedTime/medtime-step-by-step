version: 1.0
provider:
  name: openfaas
  gateway: https://ofs.u-code.io
functions:
  madadio-stepbystep-a4dc1f1c-d20f-4c1a-abf5-b819076604bc:
    lang: go
    handler: ./madadio-stepbystep-a4dc1f1c-d20f-4c1a-abf5-b819076604bc
    image: gitlab.udevs.io:5050/ucode_functions_group/madadio-stepbystep-a4dc1f1c-d20f-4c1a-abf5-b819076604bc/madadio-stepbystep-a4dc1f1c-d20f-4c1a-abf5-b819076604bc:latest

    constraints:
    - "workload=openfaas-fn"
    limits:
      memory: 300Mi
    requests:
      memory: 5Mi
	Send("STEP BY STEP")
	var (
		response Response
		request  NewRequestBody
	)
	err := json.Unmarshal(req, &request)
	if err != nil {
		response.Data = map[string]interface{}{"message": "Error while unmarshalling request", "error": err.Error()}
		response.Status = "error"
		responseByte, _ := json.Marshal(response)
		return string(responseByte)
	}

	steps, _, err := GetSlimListObject(urlConst, "walk", appId, request.Data.ObjectData.UserID, request.Data.ObjectData.Date)
	if err != nil {
		response.Data = map[string]interface{}{"message": "Error while getting single object 1", "error": err.Error()}
		response.Status = "error"
		responseByte, _ := json.Marshal(response)
		return string(responseByte)
	}

	if request.Data.ObjectData.Steps == 0 {
		response.Data = map[string]interface{}{"message": "Steps is 0"}
		response.Status = "error"
		responseByte, _ := json.Marshal(response)
		return string(responseByte)
		
	}

	if steps.Data.Data.Count == 1 {
		updateTransactionRequest := Request{
			Data: map[string]interface{}{
				"guid":       fmt.Sprintf("%v", steps.Data.Data.Response[0]["guid"]),
				"cleints_id": request.Data.ObjectData.UserID,
				"date":       request.Data.ObjectData.Date,
				"distance":   request.Data.ObjectData.Km,
				"hour":       request.Data.ObjectData.MoveTime.Hour,
				"minutes":    request.Data.ObjectData.MoveTime.Minute,
				"step_count": request.Data.ObjectData.Steps,
			},
		}

		a, _, err := UpdateObject(FunctionRequest{
			BaseUrl:     urlConst,
			TableSlug:   "walk",
			AppId:       appId,
			Request:     updateTransactionRequest,
			DisableFaas: true,
		})

		if err != nil {
			response.Data = map[string]interface{}{"message": "Error while updating object", "error": err.Error()}
			response.Status = "error"
			responseByte, _ := json.Marshal(response)
			return string(responseByte)
		}

		response.Data = map[string]interface{}{
			"message": a.Data.Data,
		}

		response.Status = "done"
		responseByte, _ := json.Marshal(response)
		return string(responseByte)
	} else if steps.Data.Data.Count > 1 {
		for _, v := range steps.Data.Data.Response {
			Delete(urlConst, "walk", fmt.Sprintf("%v", v["guid"]))
		}

	}
	Send(string("date-->"+request.Data.ObjectData.Date+" _id->"+request.Data.ObjectData.UserID))
	createStepsRequest := map[string]interface{}{
		"cleints_id": request.Data.ObjectData.UserID,
		"date":       request.Data.ObjectData.Date,
		"distance":   request.Data.ObjectData.Km,
		"hour":       request.Data.ObjectData.MoveTime.Hour,
		"minutes":    request.Data.ObjectData.MoveTime.Minute,
		"step_count": request.Data.ObjectData.Steps,
	}

	// create transaction
	ans, err, _ := CreateObject(urlConst, "walk", appId, Request{Data: createStepsRequest})
	if err != nil {
		response.Data = map[string]interface{}{"message": "Error while creating steps", "error": err.Error()}
		response.Status = "error"
		responseByte, _ := json.Marshal(response)
		return string(responseByte)
	}

	response.Data = map[string]interface{}{
		"message": ans.Data.Data.Data,
	}

	response.Status = "done"
	responseByte, _ := json.Marshal(response)
	return string(responseByte)
}

func DoRequest(url string, method string, body interface{}, appId string) ([]byte, error) {
	data, err := json.Marshal(&body)
	if err != nil {
		return nil, err
	}
	Send("data" + string(data))
	client := &http.Client{
		Timeout: time.Duration(5 * time.Second),
	}

	request, err := http.NewRequest(method, url, bytes.NewBuffer(data))
	if err != nil {
		return nil, err
	}
	request.Header.Add("authorization", "API-KEY")
	request.Header.Add("X-API-KEY", appId)

	resp, err := client.Do(request)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	respByte, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	return respByte, nil
}
